# 🔄 数据迁移详细方案

> **重要性**: ⭐⭐⭐⭐⭐ 最高  
> **风险等级**: 🔴 高危  
> **负责人**: 工程师A + 工程师D  
> **执行时间**: Week 5 Day 3

---

## 1. 迁移前检查清单

### 1.1 数据备份（必须！）

```bash
# ✅ 第1步：完整备份旧数据
cd /www/wwwroot/axs_html
mkdir -p backups/pre-migration-$(date +%Y%m%d)

# 备份JSON文件
cp data/novels.json backups/pre-migration-$(date +%Y%m%d)/
cp data/users.json backups/pre-migration-$(date +%Y%m%d)/
cp data/comments.json backups/pre-migration-$(date +%Y%m%d)/

# 备份上传的图片
tar -czf backups/pre-migration-$(date +%Y%m%d)/uploads.tar.gz public/uploads/

# 验证备份完整性
echo "备份文件列表："
ls -lh backups/pre-migration-$(date +%Y%m%d)/

# ✅ 第2步：上传到云存储（双重保险）
# 使用阿里云OSS或其他云存储
ossutil cp -r backups/pre-migration-$(date +%Y%m%d)/ oss://your-bucket/backups/
```

### 1.2 数据质量分析

```bash
[ ] 统计旧数据总量
    - 用户数: ____
    - 小说数: ____
    - 评论数: ____
    - 标签数: ____

[ ] 检查数据完整性
    - 是否有无效的用户ID引用
    - 是否有空标题的小说
    - 是否有损坏的JSON结构

[ ] 识别脏数据
    - 重复的邮箱地址
    - 异常的日期格式
    - 缺失必填字段
```

---

## 2. 迁移策略

### 2.1 三阶段迁移法

```
阶段1: 测试环境迁移（Week 4 Day 5）
├── 目的：验证迁移脚本正确性
├── 数据：使用生产数据副本
├── 时长：2小时
└── 验收：100%数据完整性校验通过

阶段2: 灰度迁移（Week 5 Day 3 下午）
├── 目的：小范围验证新系统
├── 数据：迁移50%的数据
├── 时长：4小时
└── 验收：用户可以访问新旧两个系统

阶段3: 全量迁移（Week 5 Day 4 凌晨2:00）
├── 目的：完整数据迁移
├── 数据：剩余50%数据 + 增量更新
├── 时长：6小时
└── 验收：新系统上线，旧系统只读模式
```

### 2.2 迁移时间窗口

**最佳时间**: 周四凌晨 2:00 - 8:00（用户访问量最低）

```
01:30 - 02:00  团队准备，最后检查
02:00 - 02:30  旧系统切换为只读模式
02:30 - 05:00  执行数据迁移
05:00 - 06:00  数据验证
06:00 - 07:00  新系统预热测试
07:00 - 08:00  DNS切换 + 监控
08:00+         正式上线
```

---

## 3. 迁移脚本（详细版）

### 3.1 主迁移脚本

```typescript
// scripts/migrate-production.ts
import { PrismaClient } from '@prisma/client'
import fs from 'fs'
import path from 'path'
import { createHash } from 'crypto'

const prisma = new PrismaClient()

interface MigrationStats {
  users: { success: number; failed: number; errors: string[] }
  novels: { success: number; failed: number; errors: string[] }
  comments: { success: number; failed: number; errors: string[] }
  tags: { success: number; failed: number; errors: string[] }
  categories: { success: number; failed: number; errors: string[] }
}

interface OldNovelData {
  novels: Array<{
    id: number
    title: string
    summary?: string
    content: string
    authorId?: number
    tags?: string[]
    category?: string
    coverData?: any
    views?: number
    likes?: number
    favorites?: number
    publishTime?: string
    status?: string
    accessLevel?: string
  }>
}

interface OldUserData {
  users: Array<{
    id: number
    email: string
    username: string
    password: string
    avatar?: string
    bio?: string
    registerTime?: string
    lastLogin?: string
    role?: string
  }>
}

async function main() {
  console.log('🚀 ========================================')
  console.log('   开始生产环境数据迁移')
  console.log('   时间:', new Date().toISOString())
  console.log('========================================\n')

  const startTime = Date.now()
  const stats: MigrationStats = {
    users: { success: 0, failed: 0, errors: [] },
    novels: { success: 0, failed: 0, errors: [] },
    comments: { success: 0, failed: 0, errors: [] },
    tags: { success: 0, failed: 0, errors: [] },
    categories: { success: 0, failed: 0, errors: [] }
  }

  try {
    // ===== 步骤0: 环境检查 =====
    console.log('🔍 Step 0: 环境检查...')
    await healthCheck()
    console.log('   ✓ 数据库连接正常')
    console.log('   ✓ 磁盘空间充足')
    console.log('   ✓ 备份文件存在\n')

    // ===== 步骤1: 读取旧数据 =====
    console.log('📖 Step 1: 读取旧数据文件...')
    const oldDataPath = path.join(process.cwd(), '../data')
    
    const oldNovelsRaw = fs.readFileSync(
      path.join(oldDataPath, 'novels.json'),
      'utf-8'
    )
    const oldUsersRaw = fs.readFileSync(
      path.join(oldDataPath, 'users.json'),
      'utf-8'
    )
    
    const oldNovelsData: OldNovelData = JSON.parse(oldNovelsRaw)
    const oldUsersData: OldUserData = JSON.parse(oldUsersRaw)
    
    // 数据完整性校验
    const novelsChecksum = createHash('md5').update(oldNovelsRaw).digest('hex')
    const usersChecksum = createHash('md5').update(oldUsersRaw).digest('hex')
    
    console.log(`   ✓ 发现 ${oldUsersData.users?.length || 0} 个用户`)
    console.log(`   ✓ 发现 ${oldNovelsData.novels?.length || 0} 部小说`)
    console.log(`   ✓ 用户数据校验和: ${usersChecksum}`)
    console.log(`   ✓ 小说数据校验和: ${novelsChecksum}\n`)

    // 记录校验和用于后续验证
    fs.writeFileSync('migration-checksums.json', JSON.stringify({
      novels: novelsChecksum,
      users: usersChecksum,
      timestamp: new Date().toISOString()
    }))

    // ===== 步骤2: 清空目标数据库（测试环境用，生产环境慎用！）=====
    if (process.env.NODE_ENV !== 'production') {
      console.log('⚠️  Step 2: 清空测试数据库...')
      await prisma.novelTag.deleteMany()
      await prisma.comment.deleteMany()
      await prisma.like.deleteMany()
      await prisma.favorite.deleteMany()
      await prisma.follow.deleteMany()
      await prisma.novel.deleteMany()
      await prisma.tag.deleteMany()
      await prisma.category.deleteMany()
      await prisma.session.deleteMany()
      await prisma.user.deleteMany()
      console.log('   ✓ 数据库已清空\n')
    }

    // ===== 步骤3: 迁移用户 =====
    console.log('👤 Step 3: 迁移用户数据...')
    const userIdMap = new Map<number, number>()
    
    for (const [index, oldUser] of (oldUsersData.users || []).entries()) {
      try {
        console.log(`   [${index + 1}/${oldUsersData.users.length}] 处理用户: ${oldUser.username}`)

        // 检查用户是否已存在
        const existingUser = await prisma.user.findFirst({
          where: {
            OR: [
              { email: oldUser.email },
              { username: oldUser.username }
            ]
          }
        })
        
        if (existingUser) {
          console.log(`     ⚠️  用户已存在，跳过: ${oldUser.username}`)
          userIdMap.set(oldUser.id, existingUser.id)
          continue
        }

        // 数据清洗和验证
        const email = oldUser.email || `user${oldUser.id}@migration.local`
        const username = oldUser.username?.trim() || `user_${oldUser.id}`
        
        // 创建新用户
        const newUser = await prisma.user.create({
          data: {
            email,
            username,
            password: oldUser.password || 'MIGRATED_NO_PASSWORD', // 已加密
            avatar: oldUser.avatar || null,
            bio: oldUser.bio || null,
            role: oldUser.role === 'admin' ? 'ADMIN' : 'USER',
            status: 'ACTIVE',
            createdAt: oldUser.registerTime 
              ? new Date(oldUser.registerTime) 
              : new Date(),
            lastLoginAt: oldUser.lastLogin 
              ? new Date(oldUser.lastLogin) 
              : null
          }
        })
        
        userIdMap.set(oldUser.id, newUser.id)
        stats.users.success++
        console.log(`     ✓ 迁移成功: ${oldUser.username} (${oldUser.id} → ${newUser.id})`)
        
      } catch (error: any) {
        stats.users.failed++
        const errorMsg = `用户 ${oldUser.username}: ${error.message}`
        stats.users.errors.push(errorMsg)
        console.error(`     ✗ 失败: ${errorMsg}`)
      }
    }
    
    console.log(`\n   📊 用户迁移完成: 成功 ${stats.users.success}, 失败 ${stats.users.failed}\n`)

    // ===== 步骤4: 迁移分类和标签 =====
    console.log('🏷️  Step 4: 迁移分类和标签...')
    const tagMap = new Map<string, number>()
    const categoryMap = new Map<string, number>()
    
    // 收集所有唯一标签和分类
    const allTags = new Set<string>()
    const allCategories = new Set<string>()
    
    for (const novel of oldNovelsData.novels || []) {
      if (novel.tags && Array.isArray(novel.tags)) {
        novel.tags.forEach(tag => allTags.add(tag.trim()))
      }
      if (novel.category) {
        allCategories.add(novel.category.trim())
      }
    }
    
    console.log(`   发现 ${allTags.size} 个唯一标签`)
    console.log(`   发现 ${allCategories.size} 个唯一分类`)
    
    // 创建标签
    for (const tagName of allTags) {
      try {
        const tag = await prisma.tag.upsert({
          where: { name: tagName },
          create: {
            name: tagName,
            slug: slugify(tagName)
          },
          update: {}
        })
        tagMap.set(tagName, tag.id)
        stats.tags.success++
        console.log(`   ✓ 标签: ${tagName}`)
      } catch (error: any) {
        stats.tags.failed++
        console.error(`   ✗ 标签失败: ${tagName} - ${error.message}`)
      }
    }
    
    // 创建分类
    for (const categoryName of allCategories) {
      try {
        const category = await prisma.category.upsert({
          where: { name: categoryName },
          create: {
            name: categoryName,
            slug: slugify(categoryName),
            description: `${categoryName}类小说`
          },
          update: {}
        })
        categoryMap.set(categoryName, category.id)
        stats.categories.success++
        console.log(`   ✓ 分类: ${categoryName}`)
      } catch (error) {
        console.error(`   ✗ 分类失败: ${categoryName}`)
      }
    }
    
    console.log(`\n   📊 标签迁移: ${stats.tags.success}/${allTags.size}`)
    console.log(`   📊 分类迁移: ${stats.categories.success}/${allCategories.size}\n`)

    // ===== 步骤5: 迁移小说 =====
    console.log('📚 Step 5: 迁移小说数据...')
    
    // 默认作者（如果旧数据没有作者信息）
    const defaultAuthorId = userIdMap.values().next().value || 1
    
    for (const [index, oldNovel] of (oldNovelsData.novels || []).entries()) {
      try {
        console.log(`   [${index + 1}/${oldNovelsData.novels.length}] 处理小说: ${oldNovel.title}`)

        // 生成唯一 slug
        const slug = `${slugify(oldNovel.title)}-${oldNovel.id}`
        
        // 检查是否已存在
        const existing = await prisma.novel.findUnique({
          where: { slug }
        })
        
        if (existing) {
          console.log(`     ⚠️  小说已存在，跳过: ${oldNovel.title}`)
          continue
        }
        
        // 确定作者ID
        let authorId = defaultAuthorId
        if (oldNovel.authorId && userIdMap.has(oldNovel.authorId)) {
          authorId = userIdMap.get(oldNovel.authorId)!
        }
        
        // 确定分类ID
        const categoryId = oldNovel.category 
          ? categoryMap.get(oldNovel.category.trim()) 
          : null
        
        // 处理封面
        let coverUrl: string | null = null
        if (oldNovel.coverData) {
          if (typeof oldNovel.coverData === 'string') {
            coverUrl = oldNovel.coverData
          } else if (oldNovel.coverData.url) {
            coverUrl = oldNovel.coverData.url
          } else if (oldNovel.coverData.dataUrl) {
            // 如果是base64，需要转换为文件
            coverUrl = await saveBase64Image(oldNovel.coverData.dataUrl, oldNovel.id)
          }
        }
        
        // 清洗内容
        const content = oldNovel.content?.trim() || ''
        const summary = oldNovel.summary?.trim() || null
        
        // 准备标签关联
        const tagConnections = oldNovel.tags
          ?.map(tagName => {
            const tagId = tagMap.get(tagName.trim())
            if (!tagId) {
              console.log(`     ⚠️  找不到标签: ${tagName}`)
              return null
            }
            return {
              tag: { connect: { id: tagId } }
            }
          })
          .filter(Boolean) || []
        
        // 创建小说
        const newNovel = await prisma.novel.create({
          data: {
            title: oldNovel.title.trim(),
            slug,
            summary,
            content,
            coverUrl,
            status: oldNovel.status === 'published' ? 'PUBLISHED' : 'DRAFT',
            accessLevel: oldNovel.accessLevel?.toUpperCase() === 'VIP' ? 'VIP' : 'FREE',
            wordCount: content.length,
            views: oldNovel.views || 0,
            likesCount: oldNovel.likes || 0,
            favoritesCount: oldNovel.favorites || 0,
            authorId,
            categoryId,
            createdAt: oldNovel.publishTime 
              ? new Date(oldNovel.publishTime) 
              : new Date(),
            publishedAt: oldNovel.status === 'published' && oldNovel.publishTime
              ? new Date(oldNovel.publishTime)
              : null,
            tags: tagConnections.length > 0 ? {
              create: tagConnections as any[]
            } : undefined
          }
        })
        
        stats.novels.success++
        console.log(`     ✓ 迁移成功: ${oldNovel.title} (ID: ${newNovel.id})`)
        
      } catch (error: any) {
        stats.novels.failed++
        const errorMsg = `小说 "${oldNovel.title}": ${error.message}`
        stats.novels.errors.push(errorMsg)
        console.error(`     ✗ 失败: ${errorMsg}`)
      }
    }
    
    console.log(`\n   📊 小说迁移完成: 成功 ${stats.novels.success}, 失败 ${stats.novels.failed}\n`)

    // ===== 步骤6: 数据完整性验证 =====
    console.log('🔍 Step 6: 数据完整性验证...')
    
    const [userCount, novelCount, tagCount, categoryCount] = await Promise.all([
      prisma.user.count(),
      prisma.novel.count(),
      prisma.tag.count(),
      prisma.category.count()
    ])
    
    console.log(`   ✓ 用户总数: ${userCount} (预期: ${oldUsersData.users.length})`)
    console.log(`   ✓ 小说总数: ${novelCount} (预期: ${oldNovelsData.novels.length})`)
    console.log(`   ✓ 标签总数: ${tagCount}`)
    console.log(`   ✓ 分类总数: ${categoryCount}`)
    
    // 验证数据一致性
    const validationErrors: string[] = []
    
    if (userCount < oldUsersData.users.length * 0.95) {
      validationErrors.push(`用户数量不足，预期 ${oldUsersData.users.length}，实际 ${userCount}`)
    }
    
    if (novelCount < oldNovelsData.novels.length * 0.95) {
      validationErrors.push(`小说数量不足，预期 ${oldNovelsData.novels.length}，实际 ${novelCount}`)
    }
    
    // 抽样验证内容完整性
    const sampleNovel = await prisma.novel.findFirst({
      include: {
        author: true,
        tags: { include: { tag: true } },
        category: true
      }
    })
    
    if (sampleNovel) {
      console.log(`\n   📝 抽样验证:`)
      console.log(`     标题: ${sampleNovel.title}`)
      console.log(`     作者: ${sampleNovel.author.username}`)
      console.log(`     标签: ${sampleNovel.tags.map(t => t.tag.name).join(', ')}`)
      console.log(`     分类: ${sampleNovel.category?.name || '无'}`)
      console.log(`     字数: ${sampleNovel.wordCount}`)
    }

    if (validationErrors.length > 0) {
      console.error('\n   ⚠️  验证警告:')
      validationErrors.forEach(err => console.error(`     - ${err}`))
    } else {
      console.log('\n   ✅ 数据验证通过！')
    }

    // ===== 步骤7: 生成迁移报告 =====
    const endTime = Date.now()
    const duration = ((endTime - startTime) / 1000).toFixed(2)
    
    const report = {
      migrationTime: new Date().toISOString(),
      duration: `${duration}秒`,
      statistics: stats,
      finalCounts: {
        users: userCount,
        novels: novelCount,
        tags: tagCount,
        categories: categoryCount
      },
      validationErrors,
      checksums: {
        novels: novelsChecksum,
        users: usersChecksum
      }
    }
    
    const reportPath = path.join(process.cwd(), `migration-report-${Date.now()}.json`)
    fs.writeFileSync(reportPath, JSON.stringify(report, null, 2))
    
    console.log('\n========================================')
    console.log('✅ 数据迁移完成！')
    console.log(`⏱️  总耗时: ${duration}秒`)
    console.log(`📄 详细报告: ${reportPath}`)
    console.log('========================================\n')
    
    // 显示错误汇总
    if (stats.users.errors.length > 0) {
      console.log('⚠️  用户迁移错误汇总:')
      stats.users.errors.slice(0, 10).forEach(err => console.log(`   - ${err}`))
      if (stats.users.errors.length > 10) {
        console.log(`   ... 还有 ${stats.users.errors.length - 10} 个错误`)
      }
    }
    
    if (stats.novels.errors.length > 0) {
      console.log('\n⚠️  小说迁移错误汇总:')
      stats.novels.errors.slice(0, 10).forEach(err => console.log(`   - ${err}`))
      if (stats.novels.errors.length > 10) {
        console.log(`   ... 还有 ${stats.novels.errors.length - 10} 个错误`)
      }
    }
    
    // 成功退出
    process.exit(0)
    
  } catch (error) {
    console.error('\n❌ ========================================')
    console.error('   迁移过程发生严重错误!')
    console.error('========================================')
    console.error(error)
    
    // 保存错误报告
    const errorReport = {
      error: error instanceof Error ? error.message : String(error),
      stack: error instanceof Error ? error.stack : undefined,
      timestamp: new Date().toISOString(),
      stats
    }
    
    fs.writeFileSync(
      `migration-error-${Date.now()}.json`,
      JSON.stringify(errorReport, null, 2)
    )
    
    process.exit(1)
  } finally {
    await prisma.$disconnect()
  }
}

// ===== 辅助函数 =====

async function healthCheck() {
  // 检查数据库连接
  await prisma.$connect()
  
  // 检查磁盘空间
  // 在Linux上可以用: execSync('df -h')
  
  // 检查备份文件
  const backupDir = path.join(process.cwd(), '../backups')
  if (!fs.existsSync(backupDir)) {
    throw new Error('备份目录不存在！请先执行数据备份')
  }
}

function slugify(text: string): string {
  return text
    .toString()
    .toLowerCase()
    .trim()
    .normalize('NFD') // 处理重音符号
    .replace(/[\u0300-\u036f]/g, '') // 移除重音
    .replace(/[^\w\s-]/g, '') // 移除特殊字符
    .replace(/[\s_-]+/g, '-') // 空格转连字符
    .replace(/^-+|-+$/g, '') // 移除首尾连字符
    .substring(0, 200) // 限制长度
}

async function saveBase64Image(dataUrl: string, novelId: number): Promise<string> {
  // 解析base64
  const matches = dataUrl.match(/^data:image\/(\w+);base64,(.+)$/)
  if (!matches) {
    throw new Error('Invalid base64 image data')
  }
  
  const ext = matches[1]
  const data = matches[2]
  const buffer = Buffer.from(data, 'base64')
  
  // 保存到uploads目录
  const filename = `novel-${novelId}-cover.${ext}`
  const filepath = path.join(process.cwd(), 'public/uploads', filename)
  
  // 确保目录存在
  const dir = path.dirname(filepath)
  if (!fs.existsSync(dir)) {
    fs.mkdirSync(dir, { recursive: true })
  }
  
  fs.writeFileSync(filepath, buffer)
  
  return `/uploads/${filename}`
}

// 执行迁移
main()
  .catch((error) => {
    console.error('Fatal error:', error)
    process.exit(1)
  })
```

### 3.2 回滚脚本

```typescript
// scripts/rollback-migration.ts
import { PrismaClient } from '@prisma/client'
import { exec } from 'child_process'
import { promisify } from 'util'

const execAsync = promisify(exec)
const prisma = new PrismaClient()

async function rollback() {
  console.log('🔄 开始数据回滚...')
  
  // 1. 停止新系统
  console.log('⏸️  停止 PM2 进程...')
  await execAsync('pm2 stop novel-platform')
  
  // 2. 恢复数据库
  console.log('🗄️  恢复数据库备份...')
  const backupFile = process.env.BACKUP_FILE || 'latest'
  await execAsync(`mysql -u root -p novel_platform_db < /www/backup/${backupFile}.sql`)
  
  // 3. 恢复旧代码
  console.log('📦 恢复旧版本代码...')
  await execAsync('git checkout v2.5.0')
  await execAsync('npm install')
  
  // 4. 重启旧系统
  console.log('🚀 启动旧系统...')
  await execAsync('pm2 restart server.js')
  
  console.log('✅ 回滚完成！')
  
  await prisma.$disconnect()
}

rollback().catch(console.error)
```

---

## 4. 验证清单

### 4.1 迁移后必须验证的项目

```bash
[ ] 数据完整性验证
    [ ] 用户数量对比: 旧系统 ____ vs 新系统 ____
    [ ] 小说数量对比: 旧系统 ____ vs 新系统 ____
    [ ] 抽查10部小说内容完整
    [ ] 抽查10个用户信息完整
    [ ] 标签关联正确
    [ ] 分类关联正确

[ ] 功能验证
    [ ] 用户可以登录
    [ ] 小说列表正常显示
    [ ] 小说详情可以打开
    [ ] 阅读器正常工作
    [ ] 点赞功能正常
    [ ] 收藏功能正常
    [ ] 评论功能正常（如果已迁移）
    [ ] 搜索功能正常
    [ ] 管理后台可访问
    [ ] 图片正常加载

[ ] 性能验证
    [ ] 首页加载时间 < 2s
    [ ] API响应时间 < 200ms
    [ ] 数据库连接池正常
    [ ] 无内存泄漏

[ ] 安全验证
    [ ] 密码仍然有效（可以登录）
    [ ] 权限控制正常
    [ ] 无SQL注入风险
```

### 4.2 自动化验证脚本

```typescript
// scripts/validate-migration.ts
import { PrismaClient } from '@prisma/client'
import fs from 'fs'
import path from 'path'

const prisma = new PrismaClient()

async function validate() {
  console.log('🔍 开始数据验证...\n')
  
  const issues: string[] = []
  
  // 1. 数量验证
  const oldNovels = JSON.parse(
    fs.readFileSync('../data/novels.json', 'utf-8')
  )
  const newNovelCount = await prisma.novel.count()
  
  if (newNovelCount < oldNovels.novels.length * 0.95) {
    issues.push(`小说数量不足: 预期 ${oldNovels.novels.length}, 实际 ${newNovelCount}`)
  } else {
    console.log(`✅ 小说数量验证通过: ${newNovelCount}/${oldNovels.novels.length}`)
  }
  
  // 2. 内容完整性验证
  const sampleIds = [1, 2, 3, 4, 5]
  for (const id of sampleIds) {
    const novel = await prisma.novel.findUnique({
      where: { id },
      include: {
        author: true,
        tags: { include: { tag: true } }
      }
    })
    
    if (novel) {
      if (!novel.title || !novel.content) {
        issues.push(`小说 ID ${id} 内容不完整`)
      } else {
        console.log(`✅ 小说 "${novel.title}" 验证通过`)
      }
    }
  }
  
  // 3. 关联验证
  const novelsWithoutAuthor = await prisma.novel.count({
    where: { authorId: null }
  })
  
  if (novelsWithoutAuthor > 0) {
    issues.push(`发现 ${novelsWithoutAuthor} 部小说没有作者`)
  }
  
  // 4. 输出结果
  console.log('\n========================================')
  if (issues.length === 0) {
    console.log('✅ 所有验证通过！')
  } else {
    console.log('❌ 发现以下问题:')
    issues.forEach(issue => console.log(`   - ${issue}`))
  }
  console.log('========================================\n')
  
  await prisma.$disconnect()
  
  return issues.length === 0
}

validate()
  .then(success => process.exit(success ? 0 : 1))
  .catch(console.error)
```

---

## 5. 应急预案

### 5.1 如果迁移失败

```bash
# 立即执行回滚
cd /www/wwwroot/novel-platform
node scripts/rollback-migration.js

# 通知团队
# 发送告警邮件/微信

# 分析原因
tail -n 100 migration-error-*.json
```

### 5.2 如果部分数据丢失

```bash
# 1. 不要panic！
# 2. 停止写入操作
pm2 stop novel-platform

# 3. 从备份恢复缺失数据
node scripts/restore-partial-data.js --missing-ids=1,2,3

# 4. 重新验证
node scripts/validate-migration.js
```

### 5.3 如果新系统访问缓慢

```bash
# 1. 检查数据库连接池
# 2. 检查索引是否创建
mysql> SHOW INDEX FROM novels;

# 3. 创建缺失索引
mysql> CREATE INDEX idx_novels_status ON novels(status);

# 4. 重启应用
pm2 restart novel-platform
```

---

## 6. 联系方式（应急）

```
角色              姓名    电话          职责
---------------------------------------------------
项目经理          张三    138****1234   总体协调
数据库专家(A)     李四    139****5678   数据迁移执行
运维专家(C)       王五    137****9012   系统监控
```

---

## 7. 迁移检查表（必须打印并填写）

```
时间节点                   负责人    完成时间    签名
---------------------------------------------------
[ ] 备份旧数据              工程师A   ______    ______
[ ] 测试环境迁移验证        工程师A   ______    ______
[ ] 生产环境迁移执行        工程师A   ______    ______
[ ] 数据完整性验证          工程师D   ______    ______
[ ] 功能测试               工程师B   ______    ______
[ ] 性能测试               工程师D   ______    ______
[ ] 上线审批               PM        ______    ______
```

---

**最后更新**: 2025-10-26  
**文档状态**: ✅ 必须执行

