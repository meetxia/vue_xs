# ğŸ”„ æ•°æ®è¿ç§»è¯¦ç»†æ–¹æ¡ˆ

> **é‡è¦æ€§**: â­â­â­â­â­ æœ€é«˜  
> **é£é™©ç­‰çº§**: ğŸ”´ é«˜å±  
> **è´Ÿè´£äºº**: å·¥ç¨‹å¸ˆA + å·¥ç¨‹å¸ˆD  
> **æ‰§è¡Œæ—¶é—´**: Week 5 Day 3

---

## 1. è¿ç§»å‰æ£€æŸ¥æ¸…å•

### 1.1 æ•°æ®å¤‡ä»½ï¼ˆå¿…é¡»ï¼ï¼‰

```bash
# âœ… ç¬¬1æ­¥ï¼šå®Œæ•´å¤‡ä»½æ—§æ•°æ®
cd /www/wwwroot/axs_html
mkdir -p backups/pre-migration-$(date +%Y%m%d)

# å¤‡ä»½JSONæ–‡ä»¶
cp data/novels.json backups/pre-migration-$(date +%Y%m%d)/
cp data/users.json backups/pre-migration-$(date +%Y%m%d)/
cp data/comments.json backups/pre-migration-$(date +%Y%m%d)/

# å¤‡ä»½ä¸Šä¼ çš„å›¾ç‰‡
tar -czf backups/pre-migration-$(date +%Y%m%d)/uploads.tar.gz public/uploads/

# éªŒè¯å¤‡ä»½å®Œæ•´æ€§
echo "å¤‡ä»½æ–‡ä»¶åˆ—è¡¨ï¼š"
ls -lh backups/pre-migration-$(date +%Y%m%d)/

# âœ… ç¬¬2æ­¥ï¼šä¸Šä¼ åˆ°äº‘å­˜å‚¨ï¼ˆåŒé‡ä¿é™©ï¼‰
# ä½¿ç”¨é˜¿é‡Œäº‘OSSæˆ–å…¶ä»–äº‘å­˜å‚¨
ossutil cp -r backups/pre-migration-$(date +%Y%m%d)/ oss://your-bucket/backups/
```

### 1.2 æ•°æ®è´¨é‡åˆ†æ

```bash
[ ] ç»Ÿè®¡æ—§æ•°æ®æ€»é‡
    - ç”¨æˆ·æ•°: ____
    - å°è¯´æ•°: ____
    - è¯„è®ºæ•°: ____
    - æ ‡ç­¾æ•°: ____

[ ] æ£€æŸ¥æ•°æ®å®Œæ•´æ€§
    - æ˜¯å¦æœ‰æ— æ•ˆçš„ç”¨æˆ·IDå¼•ç”¨
    - æ˜¯å¦æœ‰ç©ºæ ‡é¢˜çš„å°è¯´
    - æ˜¯å¦æœ‰æŸåçš„JSONç»“æ„

[ ] è¯†åˆ«è„æ•°æ®
    - é‡å¤çš„é‚®ç®±åœ°å€
    - å¼‚å¸¸çš„æ—¥æœŸæ ¼å¼
    - ç¼ºå¤±å¿…å¡«å­—æ®µ
```

---

## 2. è¿ç§»ç­–ç•¥

### 2.1 ä¸‰é˜¶æ®µè¿ç§»æ³•

```
é˜¶æ®µ1: æµ‹è¯•ç¯å¢ƒè¿ç§»ï¼ˆWeek 4 Day 5ï¼‰
â”œâ”€â”€ ç›®çš„ï¼šéªŒè¯è¿ç§»è„šæœ¬æ­£ç¡®æ€§
â”œâ”€â”€ æ•°æ®ï¼šä½¿ç”¨ç”Ÿäº§æ•°æ®å‰¯æœ¬
â”œâ”€â”€ æ—¶é•¿ï¼š2å°æ—¶
â””â”€â”€ éªŒæ”¶ï¼š100%æ•°æ®å®Œæ•´æ€§æ ¡éªŒé€šè¿‡

é˜¶æ®µ2: ç°åº¦è¿ç§»ï¼ˆWeek 5 Day 3 ä¸‹åˆï¼‰
â”œâ”€â”€ ç›®çš„ï¼šå°èŒƒå›´éªŒè¯æ–°ç³»ç»Ÿ
â”œâ”€â”€ æ•°æ®ï¼šè¿ç§»50%çš„æ•°æ®
â”œâ”€â”€ æ—¶é•¿ï¼š4å°æ—¶
â””â”€â”€ éªŒæ”¶ï¼šç”¨æˆ·å¯ä»¥è®¿é—®æ–°æ—§ä¸¤ä¸ªç³»ç»Ÿ

é˜¶æ®µ3: å…¨é‡è¿ç§»ï¼ˆWeek 5 Day 4 å‡Œæ™¨2:00ï¼‰
â”œâ”€â”€ ç›®çš„ï¼šå®Œæ•´æ•°æ®è¿ç§»
â”œâ”€â”€ æ•°æ®ï¼šå‰©ä½™50%æ•°æ® + å¢é‡æ›´æ–°
â”œâ”€â”€ æ—¶é•¿ï¼š6å°æ—¶
â””â”€â”€ éªŒæ”¶ï¼šæ–°ç³»ç»Ÿä¸Šçº¿ï¼Œæ—§ç³»ç»Ÿåªè¯»æ¨¡å¼
```

### 2.2 è¿ç§»æ—¶é—´çª—å£

**æœ€ä½³æ—¶é—´**: å‘¨å››å‡Œæ™¨ 2:00 - 8:00ï¼ˆç”¨æˆ·è®¿é—®é‡æœ€ä½ï¼‰

```
01:30 - 02:00  å›¢é˜Ÿå‡†å¤‡ï¼Œæœ€åæ£€æŸ¥
02:00 - 02:30  æ—§ç³»ç»Ÿåˆ‡æ¢ä¸ºåªè¯»æ¨¡å¼
02:30 - 05:00  æ‰§è¡Œæ•°æ®è¿ç§»
05:00 - 06:00  æ•°æ®éªŒè¯
06:00 - 07:00  æ–°ç³»ç»Ÿé¢„çƒ­æµ‹è¯•
07:00 - 08:00  DNSåˆ‡æ¢ + ç›‘æ§
08:00+         æ­£å¼ä¸Šçº¿
```

---

## 3. è¿ç§»è„šæœ¬ï¼ˆè¯¦ç»†ç‰ˆï¼‰

### 3.1 ä¸»è¿ç§»è„šæœ¬

```typescript
// scripts/migrate-production.ts
import { PrismaClient } from '@prisma/client'
import fs from 'fs'
import path from 'path'
import { createHash } from 'crypto'

const prisma = new PrismaClient()

interface MigrationStats {
  users: { success: number; failed: number; errors: string[] }
  novels: { success: number; failed: number; errors: string[] }
  comments: { success: number; failed: number; errors: string[] }
  tags: { success: number; failed: number; errors: string[] }
  categories: { success: number; failed: number; errors: string[] }
}

interface OldNovelData {
  novels: Array<{
    id: number
    title: string
    summary?: string
    content: string
    authorId?: number
    tags?: string[]
    category?: string
    coverData?: any
    views?: number
    likes?: number
    favorites?: number
    publishTime?: string
    status?: string
    accessLevel?: string
  }>
}

interface OldUserData {
  users: Array<{
    id: number
    email: string
    username: string
    password: string
    avatar?: string
    bio?: string
    registerTime?: string
    lastLogin?: string
    role?: string
  }>
}

async function main() {
  console.log('ğŸš€ ========================================')
  console.log('   å¼€å§‹ç”Ÿäº§ç¯å¢ƒæ•°æ®è¿ç§»')
  console.log('   æ—¶é—´:', new Date().toISOString())
  console.log('========================================\n')

  const startTime = Date.now()
  const stats: MigrationStats = {
    users: { success: 0, failed: 0, errors: [] },
    novels: { success: 0, failed: 0, errors: [] },
    comments: { success: 0, failed: 0, errors: [] },
    tags: { success: 0, failed: 0, errors: [] },
    categories: { success: 0, failed: 0, errors: [] }
  }

  try {
    // ===== æ­¥éª¤0: ç¯å¢ƒæ£€æŸ¥ =====
    console.log('ğŸ” Step 0: ç¯å¢ƒæ£€æŸ¥...')
    await healthCheck()
    console.log('   âœ“ æ•°æ®åº“è¿æ¥æ­£å¸¸')
    console.log('   âœ“ ç£ç›˜ç©ºé—´å……è¶³')
    console.log('   âœ“ å¤‡ä»½æ–‡ä»¶å­˜åœ¨\n')

    // ===== æ­¥éª¤1: è¯»å–æ—§æ•°æ® =====
    console.log('ğŸ“– Step 1: è¯»å–æ—§æ•°æ®æ–‡ä»¶...')
    const oldDataPath = path.join(process.cwd(), '../data')
    
    const oldNovelsRaw = fs.readFileSync(
      path.join(oldDataPath, 'novels.json'),
      'utf-8'
    )
    const oldUsersRaw = fs.readFileSync(
      path.join(oldDataPath, 'users.json'),
      'utf-8'
    )
    
    const oldNovelsData: OldNovelData = JSON.parse(oldNovelsRaw)
    const oldUsersData: OldUserData = JSON.parse(oldUsersRaw)
    
    // æ•°æ®å®Œæ•´æ€§æ ¡éªŒ
    const novelsChecksum = createHash('md5').update(oldNovelsRaw).digest('hex')
    const usersChecksum = createHash('md5').update(oldUsersRaw).digest('hex')
    
    console.log(`   âœ“ å‘ç° ${oldUsersData.users?.length || 0} ä¸ªç”¨æˆ·`)
    console.log(`   âœ“ å‘ç° ${oldNovelsData.novels?.length || 0} éƒ¨å°è¯´`)
    console.log(`   âœ“ ç”¨æˆ·æ•°æ®æ ¡éªŒå’Œ: ${usersChecksum}`)
    console.log(`   âœ“ å°è¯´æ•°æ®æ ¡éªŒå’Œ: ${novelsChecksum}\n`)

    // è®°å½•æ ¡éªŒå’Œç”¨äºåç»­éªŒè¯
    fs.writeFileSync('migration-checksums.json', JSON.stringify({
      novels: novelsChecksum,
      users: usersChecksum,
      timestamp: new Date().toISOString()
    }))

    // ===== æ­¥éª¤2: æ¸…ç©ºç›®æ ‡æ•°æ®åº“ï¼ˆæµ‹è¯•ç¯å¢ƒç”¨ï¼Œç”Ÿäº§ç¯å¢ƒæ…ç”¨ï¼ï¼‰=====
    if (process.env.NODE_ENV !== 'production') {
      console.log('âš ï¸  Step 2: æ¸…ç©ºæµ‹è¯•æ•°æ®åº“...')
      await prisma.novelTag.deleteMany()
      await prisma.comment.deleteMany()
      await prisma.like.deleteMany()
      await prisma.favorite.deleteMany()
      await prisma.follow.deleteMany()
      await prisma.novel.deleteMany()
      await prisma.tag.deleteMany()
      await prisma.category.deleteMany()
      await prisma.session.deleteMany()
      await prisma.user.deleteMany()
      console.log('   âœ“ æ•°æ®åº“å·²æ¸…ç©º\n')
    }

    // ===== æ­¥éª¤3: è¿ç§»ç”¨æˆ· =====
    console.log('ğŸ‘¤ Step 3: è¿ç§»ç”¨æˆ·æ•°æ®...')
    const userIdMap = new Map<number, number>()
    
    for (const [index, oldUser] of (oldUsersData.users || []).entries()) {
      try {
        console.log(`   [${index + 1}/${oldUsersData.users.length}] å¤„ç†ç”¨æˆ·: ${oldUser.username}`)

        // æ£€æŸ¥ç”¨æˆ·æ˜¯å¦å·²å­˜åœ¨
        const existingUser = await prisma.user.findFirst({
          where: {
            OR: [
              { email: oldUser.email },
              { username: oldUser.username }
            ]
          }
        })
        
        if (existingUser) {
          console.log(`     âš ï¸  ç”¨æˆ·å·²å­˜åœ¨ï¼Œè·³è¿‡: ${oldUser.username}`)
          userIdMap.set(oldUser.id, existingUser.id)
          continue
        }

        // æ•°æ®æ¸…æ´—å’ŒéªŒè¯
        const email = oldUser.email || `user${oldUser.id}@migration.local`
        const username = oldUser.username?.trim() || `user_${oldUser.id}`
        
        // åˆ›å»ºæ–°ç”¨æˆ·
        const newUser = await prisma.user.create({
          data: {
            email,
            username,
            password: oldUser.password || 'MIGRATED_NO_PASSWORD', // å·²åŠ å¯†
            avatar: oldUser.avatar || null,
            bio: oldUser.bio || null,
            role: oldUser.role === 'admin' ? 'ADMIN' : 'USER',
            status: 'ACTIVE',
            createdAt: oldUser.registerTime 
              ? new Date(oldUser.registerTime) 
              : new Date(),
            lastLoginAt: oldUser.lastLogin 
              ? new Date(oldUser.lastLogin) 
              : null
          }
        })
        
        userIdMap.set(oldUser.id, newUser.id)
        stats.users.success++
        console.log(`     âœ“ è¿ç§»æˆåŠŸ: ${oldUser.username} (${oldUser.id} â†’ ${newUser.id})`)
        
      } catch (error: any) {
        stats.users.failed++
        const errorMsg = `ç”¨æˆ· ${oldUser.username}: ${error.message}`
        stats.users.errors.push(errorMsg)
        console.error(`     âœ— å¤±è´¥: ${errorMsg}`)
      }
    }
    
    console.log(`\n   ğŸ“Š ç”¨æˆ·è¿ç§»å®Œæˆ: æˆåŠŸ ${stats.users.success}, å¤±è´¥ ${stats.users.failed}\n`)

    // ===== æ­¥éª¤4: è¿ç§»åˆ†ç±»å’Œæ ‡ç­¾ =====
    console.log('ğŸ·ï¸  Step 4: è¿ç§»åˆ†ç±»å’Œæ ‡ç­¾...')
    const tagMap = new Map<string, number>()
    const categoryMap = new Map<string, number>()
    
    // æ”¶é›†æ‰€æœ‰å”¯ä¸€æ ‡ç­¾å’Œåˆ†ç±»
    const allTags = new Set<string>()
    const allCategories = new Set<string>()
    
    for (const novel of oldNovelsData.novels || []) {
      if (novel.tags && Array.isArray(novel.tags)) {
        novel.tags.forEach(tag => allTags.add(tag.trim()))
      }
      if (novel.category) {
        allCategories.add(novel.category.trim())
      }
    }
    
    console.log(`   å‘ç° ${allTags.size} ä¸ªå”¯ä¸€æ ‡ç­¾`)
    console.log(`   å‘ç° ${allCategories.size} ä¸ªå”¯ä¸€åˆ†ç±»`)
    
    // åˆ›å»ºæ ‡ç­¾
    for (const tagName of allTags) {
      try {
        const tag = await prisma.tag.upsert({
          where: { name: tagName },
          create: {
            name: tagName,
            slug: slugify(tagName)
          },
          update: {}
        })
        tagMap.set(tagName, tag.id)
        stats.tags.success++
        console.log(`   âœ“ æ ‡ç­¾: ${tagName}`)
      } catch (error: any) {
        stats.tags.failed++
        console.error(`   âœ— æ ‡ç­¾å¤±è´¥: ${tagName} - ${error.message}`)
      }
    }
    
    // åˆ›å»ºåˆ†ç±»
    for (const categoryName of allCategories) {
      try {
        const category = await prisma.category.upsert({
          where: { name: categoryName },
          create: {
            name: categoryName,
            slug: slugify(categoryName),
            description: `${categoryName}ç±»å°è¯´`
          },
          update: {}
        })
        categoryMap.set(categoryName, category.id)
        stats.categories.success++
        console.log(`   âœ“ åˆ†ç±»: ${categoryName}`)
      } catch (error) {
        console.error(`   âœ— åˆ†ç±»å¤±è´¥: ${categoryName}`)
      }
    }
    
    console.log(`\n   ğŸ“Š æ ‡ç­¾è¿ç§»: ${stats.tags.success}/${allTags.size}`)
    console.log(`   ğŸ“Š åˆ†ç±»è¿ç§»: ${stats.categories.success}/${allCategories.size}\n`)

    // ===== æ­¥éª¤5: è¿ç§»å°è¯´ =====
    console.log('ğŸ“š Step 5: è¿ç§»å°è¯´æ•°æ®...')
    
    // é»˜è®¤ä½œè€…ï¼ˆå¦‚æœæ—§æ•°æ®æ²¡æœ‰ä½œè€…ä¿¡æ¯ï¼‰
    const defaultAuthorId = userIdMap.values().next().value || 1
    
    for (const [index, oldNovel] of (oldNovelsData.novels || []).entries()) {
      try {
        console.log(`   [${index + 1}/${oldNovelsData.novels.length}] å¤„ç†å°è¯´: ${oldNovel.title}`)

        // ç”Ÿæˆå”¯ä¸€ slug
        const slug = `${slugify(oldNovel.title)}-${oldNovel.id}`
        
        // æ£€æŸ¥æ˜¯å¦å·²å­˜åœ¨
        const existing = await prisma.novel.findUnique({
          where: { slug }
        })
        
        if (existing) {
          console.log(`     âš ï¸  å°è¯´å·²å­˜åœ¨ï¼Œè·³è¿‡: ${oldNovel.title}`)
          continue
        }
        
        // ç¡®å®šä½œè€…ID
        let authorId = defaultAuthorId
        if (oldNovel.authorId && userIdMap.has(oldNovel.authorId)) {
          authorId = userIdMap.get(oldNovel.authorId)!
        }
        
        // ç¡®å®šåˆ†ç±»ID
        const categoryId = oldNovel.category 
          ? categoryMap.get(oldNovel.category.trim()) 
          : null
        
        // å¤„ç†å°é¢
        let coverUrl: string | null = null
        if (oldNovel.coverData) {
          if (typeof oldNovel.coverData === 'string') {
            coverUrl = oldNovel.coverData
          } else if (oldNovel.coverData.url) {
            coverUrl = oldNovel.coverData.url
          } else if (oldNovel.coverData.dataUrl) {
            // å¦‚æœæ˜¯base64ï¼Œéœ€è¦è½¬æ¢ä¸ºæ–‡ä»¶
            coverUrl = await saveBase64Image(oldNovel.coverData.dataUrl, oldNovel.id)
          }
        }
        
        // æ¸…æ´—å†…å®¹
        const content = oldNovel.content?.trim() || ''
        const summary = oldNovel.summary?.trim() || null
        
        // å‡†å¤‡æ ‡ç­¾å…³è”
        const tagConnections = oldNovel.tags
          ?.map(tagName => {
            const tagId = tagMap.get(tagName.trim())
            if (!tagId) {
              console.log(`     âš ï¸  æ‰¾ä¸åˆ°æ ‡ç­¾: ${tagName}`)
              return null
            }
            return {
              tag: { connect: { id: tagId } }
            }
          })
          .filter(Boolean) || []
        
        // åˆ›å»ºå°è¯´
        const newNovel = await prisma.novel.create({
          data: {
            title: oldNovel.title.trim(),
            slug,
            summary,
            content,
            coverUrl,
            status: oldNovel.status === 'published' ? 'PUBLISHED' : 'DRAFT',
            accessLevel: oldNovel.accessLevel?.toUpperCase() === 'VIP' ? 'VIP' : 'FREE',
            wordCount: content.length,
            views: oldNovel.views || 0,
            likesCount: oldNovel.likes || 0,
            favoritesCount: oldNovel.favorites || 0,
            authorId,
            categoryId,
            createdAt: oldNovel.publishTime 
              ? new Date(oldNovel.publishTime) 
              : new Date(),
            publishedAt: oldNovel.status === 'published' && oldNovel.publishTime
              ? new Date(oldNovel.publishTime)
              : null,
            tags: tagConnections.length > 0 ? {
              create: tagConnections as any[]
            } : undefined
          }
        })
        
        stats.novels.success++
        console.log(`     âœ“ è¿ç§»æˆåŠŸ: ${oldNovel.title} (ID: ${newNovel.id})`)
        
      } catch (error: any) {
        stats.novels.failed++
        const errorMsg = `å°è¯´ "${oldNovel.title}": ${error.message}`
        stats.novels.errors.push(errorMsg)
        console.error(`     âœ— å¤±è´¥: ${errorMsg}`)
      }
    }
    
    console.log(`\n   ğŸ“Š å°è¯´è¿ç§»å®Œæˆ: æˆåŠŸ ${stats.novels.success}, å¤±è´¥ ${stats.novels.failed}\n`)

    // ===== æ­¥éª¤6: æ•°æ®å®Œæ•´æ€§éªŒè¯ =====
    console.log('ğŸ” Step 6: æ•°æ®å®Œæ•´æ€§éªŒè¯...')
    
    const [userCount, novelCount, tagCount, categoryCount] = await Promise.all([
      prisma.user.count(),
      prisma.novel.count(),
      prisma.tag.count(),
      prisma.category.count()
    ])
    
    console.log(`   âœ“ ç”¨æˆ·æ€»æ•°: ${userCount} (é¢„æœŸ: ${oldUsersData.users.length})`)
    console.log(`   âœ“ å°è¯´æ€»æ•°: ${novelCount} (é¢„æœŸ: ${oldNovelsData.novels.length})`)
    console.log(`   âœ“ æ ‡ç­¾æ€»æ•°: ${tagCount}`)
    console.log(`   âœ“ åˆ†ç±»æ€»æ•°: ${categoryCount}`)
    
    // éªŒè¯æ•°æ®ä¸€è‡´æ€§
    const validationErrors: string[] = []
    
    if (userCount < oldUsersData.users.length * 0.95) {
      validationErrors.push(`ç”¨æˆ·æ•°é‡ä¸è¶³ï¼Œé¢„æœŸ ${oldUsersData.users.length}ï¼Œå®é™… ${userCount}`)
    }
    
    if (novelCount < oldNovelsData.novels.length * 0.95) {
      validationErrors.push(`å°è¯´æ•°é‡ä¸è¶³ï¼Œé¢„æœŸ ${oldNovelsData.novels.length}ï¼Œå®é™… ${novelCount}`)
    }
    
    // æŠ½æ ·éªŒè¯å†…å®¹å®Œæ•´æ€§
    const sampleNovel = await prisma.novel.findFirst({
      include: {
        author: true,
        tags: { include: { tag: true } },
        category: true
      }
    })
    
    if (sampleNovel) {
      console.log(`\n   ğŸ“ æŠ½æ ·éªŒè¯:`)
      console.log(`     æ ‡é¢˜: ${sampleNovel.title}`)
      console.log(`     ä½œè€…: ${sampleNovel.author.username}`)
      console.log(`     æ ‡ç­¾: ${sampleNovel.tags.map(t => t.tag.name).join(', ')}`)
      console.log(`     åˆ†ç±»: ${sampleNovel.category?.name || 'æ— '}`)
      console.log(`     å­—æ•°: ${sampleNovel.wordCount}`)
    }

    if (validationErrors.length > 0) {
      console.error('\n   âš ï¸  éªŒè¯è­¦å‘Š:')
      validationErrors.forEach(err => console.error(`     - ${err}`))
    } else {
      console.log('\n   âœ… æ•°æ®éªŒè¯é€šè¿‡ï¼')
    }

    // ===== æ­¥éª¤7: ç”Ÿæˆè¿ç§»æŠ¥å‘Š =====
    const endTime = Date.now()
    const duration = ((endTime - startTime) / 1000).toFixed(2)
    
    const report = {
      migrationTime: new Date().toISOString(),
      duration: `${duration}ç§’`,
      statistics: stats,
      finalCounts: {
        users: userCount,
        novels: novelCount,
        tags: tagCount,
        categories: categoryCount
      },
      validationErrors,
      checksums: {
        novels: novelsChecksum,
        users: usersChecksum
      }
    }
    
    const reportPath = path.join(process.cwd(), `migration-report-${Date.now()}.json`)
    fs.writeFileSync(reportPath, JSON.stringify(report, null, 2))
    
    console.log('\n========================================')
    console.log('âœ… æ•°æ®è¿ç§»å®Œæˆï¼')
    console.log(`â±ï¸  æ€»è€—æ—¶: ${duration}ç§’`)
    console.log(`ğŸ“„ è¯¦ç»†æŠ¥å‘Š: ${reportPath}`)
    console.log('========================================\n')
    
    // æ˜¾ç¤ºé”™è¯¯æ±‡æ€»
    if (stats.users.errors.length > 0) {
      console.log('âš ï¸  ç”¨æˆ·è¿ç§»é”™è¯¯æ±‡æ€»:')
      stats.users.errors.slice(0, 10).forEach(err => console.log(`   - ${err}`))
      if (stats.users.errors.length > 10) {
        console.log(`   ... è¿˜æœ‰ ${stats.users.errors.length - 10} ä¸ªé”™è¯¯`)
      }
    }
    
    if (stats.novels.errors.length > 0) {
      console.log('\nâš ï¸  å°è¯´è¿ç§»é”™è¯¯æ±‡æ€»:')
      stats.novels.errors.slice(0, 10).forEach(err => console.log(`   - ${err}`))
      if (stats.novels.errors.length > 10) {
        console.log(`   ... è¿˜æœ‰ ${stats.novels.errors.length - 10} ä¸ªé”™è¯¯`)
      }
    }
    
    // æˆåŠŸé€€å‡º
    process.exit(0)
    
  } catch (error) {
    console.error('\nâŒ ========================================')
    console.error('   è¿ç§»è¿‡ç¨‹å‘ç”Ÿä¸¥é‡é”™è¯¯!')
    console.error('========================================')
    console.error(error)
    
    // ä¿å­˜é”™è¯¯æŠ¥å‘Š
    const errorReport = {
      error: error instanceof Error ? error.message : String(error),
      stack: error instanceof Error ? error.stack : undefined,
      timestamp: new Date().toISOString(),
      stats
    }
    
    fs.writeFileSync(
      `migration-error-${Date.now()}.json`,
      JSON.stringify(errorReport, null, 2)
    )
    
    process.exit(1)
  } finally {
    await prisma.$disconnect()
  }
}

// ===== è¾…åŠ©å‡½æ•° =====

async function healthCheck() {
  // æ£€æŸ¥æ•°æ®åº“è¿æ¥
  await prisma.$connect()
  
  // æ£€æŸ¥ç£ç›˜ç©ºé—´
  // åœ¨Linuxä¸Šå¯ä»¥ç”¨: execSync('df -h')
  
  // æ£€æŸ¥å¤‡ä»½æ–‡ä»¶
  const backupDir = path.join(process.cwd(), '../backups')
  if (!fs.existsSync(backupDir)) {
    throw new Error('å¤‡ä»½ç›®å½•ä¸å­˜åœ¨ï¼è¯·å…ˆæ‰§è¡Œæ•°æ®å¤‡ä»½')
  }
}

function slugify(text: string): string {
  return text
    .toString()
    .toLowerCase()
    .trim()
    .normalize('NFD') // å¤„ç†é‡éŸ³ç¬¦å·
    .replace(/[\u0300-\u036f]/g, '') // ç§»é™¤é‡éŸ³
    .replace(/[^\w\s-]/g, '') // ç§»é™¤ç‰¹æ®Šå­—ç¬¦
    .replace(/[\s_-]+/g, '-') // ç©ºæ ¼è½¬è¿å­—ç¬¦
    .replace(/^-+|-+$/g, '') // ç§»é™¤é¦–å°¾è¿å­—ç¬¦
    .substring(0, 200) // é™åˆ¶é•¿åº¦
}

async function saveBase64Image(dataUrl: string, novelId: number): Promise<string> {
  // è§£æbase64
  const matches = dataUrl.match(/^data:image\/(\w+);base64,(.+)$/)
  if (!matches) {
    throw new Error('Invalid base64 image data')
  }
  
  const ext = matches[1]
  const data = matches[2]
  const buffer = Buffer.from(data, 'base64')
  
  // ä¿å­˜åˆ°uploadsç›®å½•
  const filename = `novel-${novelId}-cover.${ext}`
  const filepath = path.join(process.cwd(), 'public/uploads', filename)
  
  // ç¡®ä¿ç›®å½•å­˜åœ¨
  const dir = path.dirname(filepath)
  if (!fs.existsSync(dir)) {
    fs.mkdirSync(dir, { recursive: true })
  }
  
  fs.writeFileSync(filepath, buffer)
  
  return `/uploads/${filename}`
}

// æ‰§è¡Œè¿ç§»
main()
  .catch((error) => {
    console.error('Fatal error:', error)
    process.exit(1)
  })
```

### 3.2 å›æ»šè„šæœ¬

```typescript
// scripts/rollback-migration.ts
import { PrismaClient } from '@prisma/client'
import { exec } from 'child_process'
import { promisify } from 'util'

const execAsync = promisify(exec)
const prisma = new PrismaClient()

async function rollback() {
  console.log('ğŸ”„ å¼€å§‹æ•°æ®å›æ»š...')
  
  // 1. åœæ­¢æ–°ç³»ç»Ÿ
  console.log('â¸ï¸  åœæ­¢ PM2 è¿›ç¨‹...')
  await execAsync('pm2 stop novel-platform')
  
  // 2. æ¢å¤æ•°æ®åº“
  console.log('ğŸ—„ï¸  æ¢å¤æ•°æ®åº“å¤‡ä»½...')
  const backupFile = process.env.BACKUP_FILE || 'latest'
  await execAsync(`mysql -u root -p novel_platform_db < /www/backup/${backupFile}.sql`)
  
  // 3. æ¢å¤æ—§ä»£ç 
  console.log('ğŸ“¦ æ¢å¤æ—§ç‰ˆæœ¬ä»£ç ...')
  await execAsync('git checkout v2.5.0')
  await execAsync('npm install')
  
  // 4. é‡å¯æ—§ç³»ç»Ÿ
  console.log('ğŸš€ å¯åŠ¨æ—§ç³»ç»Ÿ...')
  await execAsync('pm2 restart server.js')
  
  console.log('âœ… å›æ»šå®Œæˆï¼')
  
  await prisma.$disconnect()
}

rollback().catch(console.error)
```

---

## 4. éªŒè¯æ¸…å•

### 4.1 è¿ç§»åå¿…é¡»éªŒè¯çš„é¡¹ç›®

```bash
[ ] æ•°æ®å®Œæ•´æ€§éªŒè¯
    [ ] ç”¨æˆ·æ•°é‡å¯¹æ¯”: æ—§ç³»ç»Ÿ ____ vs æ–°ç³»ç»Ÿ ____
    [ ] å°è¯´æ•°é‡å¯¹æ¯”: æ—§ç³»ç»Ÿ ____ vs æ–°ç³»ç»Ÿ ____
    [ ] æŠ½æŸ¥10éƒ¨å°è¯´å†…å®¹å®Œæ•´
    [ ] æŠ½æŸ¥10ä¸ªç”¨æˆ·ä¿¡æ¯å®Œæ•´
    [ ] æ ‡ç­¾å…³è”æ­£ç¡®
    [ ] åˆ†ç±»å…³è”æ­£ç¡®

[ ] åŠŸèƒ½éªŒè¯
    [ ] ç”¨æˆ·å¯ä»¥ç™»å½•
    [ ] å°è¯´åˆ—è¡¨æ­£å¸¸æ˜¾ç¤º
    [ ] å°è¯´è¯¦æƒ…å¯ä»¥æ‰“å¼€
    [ ] é˜…è¯»å™¨æ­£å¸¸å·¥ä½œ
    [ ] ç‚¹èµåŠŸèƒ½æ­£å¸¸
    [ ] æ”¶è—åŠŸèƒ½æ­£å¸¸
    [ ] è¯„è®ºåŠŸèƒ½æ­£å¸¸ï¼ˆå¦‚æœå·²è¿ç§»ï¼‰
    [ ] æœç´¢åŠŸèƒ½æ­£å¸¸
    [ ] ç®¡ç†åå°å¯è®¿é—®
    [ ] å›¾ç‰‡æ­£å¸¸åŠ è½½

[ ] æ€§èƒ½éªŒè¯
    [ ] é¦–é¡µåŠ è½½æ—¶é—´ < 2s
    [ ] APIå“åº”æ—¶é—´ < 200ms
    [ ] æ•°æ®åº“è¿æ¥æ± æ­£å¸¸
    [ ] æ— å†…å­˜æ³„æ¼

[ ] å®‰å…¨éªŒè¯
    [ ] å¯†ç ä»ç„¶æœ‰æ•ˆï¼ˆå¯ä»¥ç™»å½•ï¼‰
    [ ] æƒé™æ§åˆ¶æ­£å¸¸
    [ ] æ— SQLæ³¨å…¥é£é™©
```

### 4.2 è‡ªåŠ¨åŒ–éªŒè¯è„šæœ¬

```typescript
// scripts/validate-migration.ts
import { PrismaClient } from '@prisma/client'
import fs from 'fs'
import path from 'path'

const prisma = new PrismaClient()

async function validate() {
  console.log('ğŸ” å¼€å§‹æ•°æ®éªŒè¯...\n')
  
  const issues: string[] = []
  
  // 1. æ•°é‡éªŒè¯
  const oldNovels = JSON.parse(
    fs.readFileSync('../data/novels.json', 'utf-8')
  )
  const newNovelCount = await prisma.novel.count()
  
  if (newNovelCount < oldNovels.novels.length * 0.95) {
    issues.push(`å°è¯´æ•°é‡ä¸è¶³: é¢„æœŸ ${oldNovels.novels.length}, å®é™… ${newNovelCount}`)
  } else {
    console.log(`âœ… å°è¯´æ•°é‡éªŒè¯é€šè¿‡: ${newNovelCount}/${oldNovels.novels.length}`)
  }
  
  // 2. å†…å®¹å®Œæ•´æ€§éªŒè¯
  const sampleIds = [1, 2, 3, 4, 5]
  for (const id of sampleIds) {
    const novel = await prisma.novel.findUnique({
      where: { id },
      include: {
        author: true,
        tags: { include: { tag: true } }
      }
    })
    
    if (novel) {
      if (!novel.title || !novel.content) {
        issues.push(`å°è¯´ ID ${id} å†…å®¹ä¸å®Œæ•´`)
      } else {
        console.log(`âœ… å°è¯´ "${novel.title}" éªŒè¯é€šè¿‡`)
      }
    }
  }
  
  // 3. å…³è”éªŒè¯
  const novelsWithoutAuthor = await prisma.novel.count({
    where: { authorId: null }
  })
  
  if (novelsWithoutAuthor > 0) {
    issues.push(`å‘ç° ${novelsWithoutAuthor} éƒ¨å°è¯´æ²¡æœ‰ä½œè€…`)
  }
  
  // 4. è¾“å‡ºç»“æœ
  console.log('\n========================================')
  if (issues.length === 0) {
    console.log('âœ… æ‰€æœ‰éªŒè¯é€šè¿‡ï¼')
  } else {
    console.log('âŒ å‘ç°ä»¥ä¸‹é—®é¢˜:')
    issues.forEach(issue => console.log(`   - ${issue}`))
  }
  console.log('========================================\n')
  
  await prisma.$disconnect()
  
  return issues.length === 0
}

validate()
  .then(success => process.exit(success ? 0 : 1))
  .catch(console.error)
```

---

## 5. åº”æ€¥é¢„æ¡ˆ

### 5.1 å¦‚æœè¿ç§»å¤±è´¥

```bash
# ç«‹å³æ‰§è¡Œå›æ»š
cd /www/wwwroot/novel-platform
node scripts/rollback-migration.js

# é€šçŸ¥å›¢é˜Ÿ
# å‘é€å‘Šè­¦é‚®ä»¶/å¾®ä¿¡

# åˆ†æåŸå› 
tail -n 100 migration-error-*.json
```

### 5.2 å¦‚æœéƒ¨åˆ†æ•°æ®ä¸¢å¤±

```bash
# 1. ä¸è¦panicï¼
# 2. åœæ­¢å†™å…¥æ“ä½œ
pm2 stop novel-platform

# 3. ä»å¤‡ä»½æ¢å¤ç¼ºå¤±æ•°æ®
node scripts/restore-partial-data.js --missing-ids=1,2,3

# 4. é‡æ–°éªŒè¯
node scripts/validate-migration.js
```

### 5.3 å¦‚æœæ–°ç³»ç»Ÿè®¿é—®ç¼“æ…¢

```bash
# 1. æ£€æŸ¥æ•°æ®åº“è¿æ¥æ± 
# 2. æ£€æŸ¥ç´¢å¼•æ˜¯å¦åˆ›å»º
mysql> SHOW INDEX FROM novels;

# 3. åˆ›å»ºç¼ºå¤±ç´¢å¼•
mysql> CREATE INDEX idx_novels_status ON novels(status);

# 4. é‡å¯åº”ç”¨
pm2 restart novel-platform
```

---

## 6. è”ç³»æ–¹å¼ï¼ˆåº”æ€¥ï¼‰

```
è§’è‰²              å§“å    ç”µè¯          èŒè´£
---------------------------------------------------
é¡¹ç›®ç»ç†          å¼ ä¸‰    138****1234   æ€»ä½“åè°ƒ
æ•°æ®åº“ä¸“å®¶(A)     æå››    139****5678   æ•°æ®è¿ç§»æ‰§è¡Œ
è¿ç»´ä¸“å®¶(C)       ç‹äº”    137****9012   ç³»ç»Ÿç›‘æ§
```

---

## 7. è¿ç§»æ£€æŸ¥è¡¨ï¼ˆå¿…é¡»æ‰“å°å¹¶å¡«å†™ï¼‰

```
æ—¶é—´èŠ‚ç‚¹                   è´Ÿè´£äºº    å®Œæˆæ—¶é—´    ç­¾å
---------------------------------------------------
[ ] å¤‡ä»½æ—§æ•°æ®              å·¥ç¨‹å¸ˆA   ______    ______
[ ] æµ‹è¯•ç¯å¢ƒè¿ç§»éªŒè¯        å·¥ç¨‹å¸ˆA   ______    ______
[ ] ç”Ÿäº§ç¯å¢ƒè¿ç§»æ‰§è¡Œ        å·¥ç¨‹å¸ˆA   ______    ______
[ ] æ•°æ®å®Œæ•´æ€§éªŒè¯          å·¥ç¨‹å¸ˆD   ______    ______
[ ] åŠŸèƒ½æµ‹è¯•               å·¥ç¨‹å¸ˆB   ______    ______
[ ] æ€§èƒ½æµ‹è¯•               å·¥ç¨‹å¸ˆD   ______    ______
[ ] ä¸Šçº¿å®¡æ‰¹               PM        ______    ______
```

---

**æœ€åæ›´æ–°**: 2025-10-26  
**æ–‡æ¡£çŠ¶æ€**: âœ… å¿…é¡»æ‰§è¡Œ

