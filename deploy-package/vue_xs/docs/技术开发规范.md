# 💻 技术开发规范

**项目：** MOMO炒饭店小说网站 V2.0  
**制定日期：** 2025-10-27  
**制定人：** 工程师A

---

## 📚 目录

1. [代码规范](#代码规范)
2. [TypeScript规范](#typescript规范)
3. [Vue 3规范](#vue-3规范)
4. [Fastify规范](#fastify规范)
5. [数据库规范](#数据库规范)
6. [测试规范](#测试规范)
7. [安全规范](#安全规范)
8. [性能规范](#性能规范)

---

## 📝 代码规范

### 命名规范

#### 文件命名

```
前端组件: PascalCase
  ✅ UserProfile.vue
  ✅ NovelCard.vue
  ❌ userProfile.vue
  ❌ novel-card.vue

工具函数: kebab-case
  ✅ format-date.ts
  ✅ validate-email.ts
  ❌ formatDate.ts
  ❌ ValidateEmail.ts

后端文件: kebab-case
  ✅ user.controller.ts
  ✅ novel.service.ts
  ✅ auth.middleware.ts
```

#### 变量命名

```typescript
// 变量和函数：camelCase
const userName = 'test'
function getUserInfo() {}

// 常量：UPPER_SNAKE_CASE
const API_BASE_URL = 'http://localhost:3000'
const MAX_FILE_SIZE = 5 * 1024 * 1024

// 类和接口：PascalCase
class UserService {}
interface NovelInfo {}

// 类型别名：PascalCase
type NovelStatus = 'draft' | 'published'
type UserRole = 'user' | 'admin'

// 枚举：PascalCase（键用UPPER_SNAKE_CASE）
enum HttpStatus {
  OK = 200,
  CREATED = 201,
  BAD_REQUEST = 400,
  UNAUTHORIZED = 401
}

// 私有属性：下划线前缀
class User {
  private _password: string
  private _encryptedData: string
}

// 布尔变量：is/has/can开头
const isLoading = true
const hasError = false
const canEdit = true
```

---

### 注释规范

#### JSDoc注释

```typescript
/**
 * 获取用户信息
 * @param userId - 用户ID
 * @param includePrivate - 是否包含私有信息
 * @returns 用户信息对象
 * @throws {NotFoundError} 用户不存在时抛出
 * @example
 * const user = await getUserInfo(1, false)
 */
async function getUserInfo(
  userId: number, 
  includePrivate: boolean = false
): Promise<UserInfo> {
  // 实现...
}
```

#### 单行注释

```typescript
// ✅ 好的注释：解释为什么
// 使用setTimeout而不是setInterval，避免内存泄漏
setTimeout(() => {...}, 1000)

// ❌ 不好的注释：重复代码
// 设置用户名为test
const username = 'test'
```

#### 代码块注释

```typescript
// ==========================================
// 用户认证相关函数
// ==========================================

// ==========================================
// 数据库查询优化
// 注意：这里使用了联表查询，注意性能
// ==========================================
```

---

### 代码组织

#### 文件长度

```
单个文件：     不超过 300 行
单个函数：     不超过 50 行
单个组件：     不超过 200 行
单个类：       不超过 300 行

超过限制？考虑拆分！
```

#### 导入顺序

```typescript
// 1. Node.js内置模块
import fs from 'fs'
import path from 'path'

// 2. 第三方库
import { FastifyInstance } from 'fastify'
import { PrismaClient } from '@prisma/client'

// 3. 项目内部模块（绝对路径）
import { UserService } from '@/services/user.service'
import { authMiddleware } from '@/middlewares/auth'

// 4. 相对路径导入
import { formatDate } from '../utils/format'
import type { UserInfo } from './types'

// 5. 样式文件
import './styles.css'
```

---

## 🔷 TypeScript规范

### 基础规范

```typescript
// ✅ 始终使用严格模式
// tsconfig.json
{
  "compilerOptions": {
    "strict": true,
    "noImplicitAny": true,
    "strictNullChecks": true
  }
}

// ✅ 显式类型声明
function calculateAge(birthYear: number): number {
  return new Date().getFullYear() - birthYear
}

// ❌ 避免使用any
function process(data: any) {} // 不好

// ✅ 使用具体类型
function process(data: UserData) {} // 好

// ✅ 使用unknown代替any（如果真的不确定）
function process(data: unknown) {
  if (typeof data === 'string') {
    // TypeScript知道这里data是string
  }
}
```

---

### 接口 vs 类型

```typescript
// ✅ 使用接口定义对象结构
interface User {
  id: number
  username: string
  email: string
}

// ✅ 使用类型别名定义联合类型
type Status = 'active' | 'inactive' | 'pending'

// ✅ 使用类型别名定义复杂类型
type ApiResponse<T> = {
  success: boolean
  data: T
  error?: string
}

// ✅ 接口可以扩展
interface AdminUser extends User {
  role: 'admin'
  permissions: string[]
}
```

---

### 泛型使用

```typescript
// ✅ 泛型函数
function findById<T>(items: T[], id: number): T | undefined {
  return items.find(item => item.id === id)
}

// ✅ 泛型接口
interface ApiResponse<T> {
  data: T
  message: string
}

// ✅ 泛型类
class DataStore<T> {
  private items: T[] = []
  
  add(item: T): void {
    this.items.push(item)
  }
  
  getAll(): T[] {
    return this.items
  }
}
```

---

### 类型守卫

```typescript
// ✅ 自定义类型守卫
function isUser(obj: any): obj is User {
  return obj && typeof obj.id === 'number' && typeof obj.username === 'string'
}

// 使用
if (isUser(data)) {
  // TypeScript知道data是User类型
  console.log(data.username)
}
```

---

## 🎨 Vue 3规范

### 组件结构

```vue
<script setup lang="ts">
// 1. 导入
import { ref, computed, onMounted } from 'vue'
import type { PropType } from 'vue'

// 2. 类型定义
interface NovelData {
  id: number
  title: string
}

// 3. Props定义
const props = defineProps<{
  novelId: number
  isEditing?: boolean
}>()

// 4. Emits定义
const emit = defineEmits<{
  save: [novel: NovelData]
  cancel: []
}>()

// 5. 响应式数据
const novel = ref<NovelData | null>(null)
const isLoading = ref(false)

// 6. 计算属性
const displayTitle = computed(() => {
  return novel.value?.title || '无标题'
})

// 7. 方法
const loadNovel = async () => {
  isLoading.value = true
  try {
    // 加载数据...
  } finally {
    isLoading.value = false
  }
}

// 8. 生命周期
onMounted(() => {
  loadNovel()
})
</script>

<template>
  <div class="novel-card">
    <!-- 模板内容 -->
  </div>
</template>

<style scoped>
/* 样式 */
</style>
```

---

### 组合式函数 (Composables)

```typescript
// src/composables/useNovel.ts
import { ref, Ref } from 'vue'
import type { Novel } from '@/types'

export function useNovel(novelId: Ref<number>) {
  const novel = ref<Novel | null>(null)
  const isLoading = ref(false)
  const error = ref<Error | null>(null)
  
  const load = async () => {
    isLoading.value = true
    error.value = null
    
    try {
      const response = await fetch(`/api/novels/${novelId.value}`)
      novel.value = await response.json()
    } catch (e) {
      error.value = e as Error
    } finally {
      isLoading.value = false
    }
  }
  
  return {
    novel,
    isLoading,
    error,
    load
  }
}
```

---

### Props验证

```typescript
// ✅ 使用TypeScript类型
defineProps<{
  title: string
  count?: number
  status: 'active' | 'inactive'
}>()

// ✅ 带默认值
interface Props {
  title: string
  count?: number
}

const props = withDefaults(defineProps<Props>(), {
  count: 0
})
```

---

### 事件处理

```vue
<script setup lang="ts">
// ✅ 类型安全的事件
const emit = defineEmits<{
  update: [value: string]
  delete: [id: number]
  'status-change': [status: 'active' | 'inactive']
}>()

const handleUpdate = (value: string) => {
  emit('update', value)
}
</script>
```

---

## ⚡ Fastify规范

### 路由定义

```typescript
// src/routes/novel.routes.ts
import { FastifyInstance } from 'fastify'
import { NovelController } from '@/controllers/novel.controller'

export default async function novelRoutes(fastify: FastifyInstance) {
  const controller = new NovelController()
  
  // 路由分组
  fastify.register(async (app) => {
    // GET /api/novels
    app.get('/', {
      schema: {
        querystring: {
          type: 'object',
          properties: {
            page: { type: 'number', default: 1 },
            pageSize: { type: 'number', default: 20 }
          }
        }
      }
    }, controller.list)
    
    // GET /api/novels/:id
    app.get('/:id', {
      schema: {
        params: {
          type: 'object',
          required: ['id'],
          properties: {
            id: { type: 'number' }
          }
        }
      }
    }, controller.getById)
  }, { prefix: '/api/novels' })
}
```

---

### 控制器规范

```typescript
// src/controllers/novel.controller.ts
import { FastifyRequest, FastifyReply } from 'fastify'
import { NovelService } from '@/services/novel.service'

interface GetNovelParams {
  id: number
}

interface ListNovelsQuery {
  page: number
  pageSize: number
}

export class NovelController {
  private novelService: NovelService
  
  constructor() {
    this.novelService = new NovelService()
  }
  
  /**
   * 获取小说列表
   */
  async list(
    request: FastifyRequest<{ Querystring: ListNovelsQuery }>,
    reply: FastifyReply
  ) {
    try {
      const { page, pageSize } = request.query
      const result = await this.novelService.list(page, pageSize)
      
      return reply.send({
        success: true,
        data: result
      })
    } catch (error) {
      return reply.code(500).send({
        success: false,
        error: error.message
      })
    }
  }
  
  /**
   * 获取小说详情
   */
  async getById(
    request: FastifyRequest<{ Params: GetNovelParams }>,
    reply: FastifyReply
  ) {
    try {
      const { id } = request.params
      const novel = await this.novelService.getById(id)
      
      if (!novel) {
        return reply.code(404).send({
          success: false,
          error: '小说不存在'
        })
      }
      
      return reply.send({
        success: true,
        data: novel
      })
    } catch (error) {
      return reply.code(500).send({
        success: false,
        error: error.message
      })
    }
  }
}
```

---

### 服务层规范

```typescript
// src/services/novel.service.ts
import { PrismaClient } from '@prisma/client'

export class NovelService {
  private prisma: PrismaClient
  
  constructor() {
    this.prisma = new PrismaClient()
  }
  
  /**
   * 获取小说列表
   */
  async list(page: number = 1, pageSize: number = 20) {
    const skip = (page - 1) * pageSize
    
    const [items, total] = await Promise.all([
      this.prisma.novel.findMany({
        skip,
        take: pageSize,
        orderBy: { createdAt: 'desc' },
        include: {
          author: {
            select: {
              id: true,
              username: true,
              avatar: true
            }
          }
        }
      }),
      this.prisma.novel.count()
    ])
    
    return {
      items,
      pagination: {
        page,
        pageSize,
        total,
        totalPages: Math.ceil(total / pageSize)
      }
    }
  }
  
  /**
   * 根据ID获取小说
   */
  async getById(id: number) {
    return await this.prisma.novel.findUnique({
      where: { id },
      include: {
        author: true
      }
    })
  }
}
```

---

### 中间件规范

```typescript
// src/middlewares/auth.middleware.ts
import { FastifyRequest, FastifyReply } from 'fastify'

export async function authMiddleware(
  request: FastifyRequest,
  reply: FastifyReply
) {
  try {
    // 验证JWT Token
    await request.jwtVerify()
  } catch (err) {
    return reply.code(401).send({
      success: false,
      error: '未授权，请先登录'
    })
  }
}
```

---

## 🗄️ 数据库规范

### Prisma Schema规范

```prisma
// schema.prisma

// 1. 表名使用复数形式
model User {
  @@map("users")
}

model Novel {
  @@map("novels")
}

// 2. 字段命名使用camelCase
model User {
  firstName  String
  lastName   String
  createdAt  DateTime
}

// 3. 外键字段以Id结尾
model Novel {
  authorId  Int
  author    User @relation(fields: [authorId], references: [id])
}

// 4. 添加索引
model Novel {
  title     String
  category  String
  
  @@index([category])
  @@index([createdAt])
  @@fulltext([title])
}

// 5. 设置级联删除
model Novel {
  authorId  Int
  author    User @relation(fields: [authorId], references: [id], onDelete: Cascade)
}

// 6. 使用枚举类型
enum UserRole {
  USER
  ADMIN
  SUPER_ADMIN
}

model User {
  role  UserRole @default(USER)
}
```

---

### 数据库查询规范

```typescript
// ✅ 使用事务
async function transferPoints(fromUserId: number, toUserId: number, amount: number) {
  await prisma.$transaction(async (tx) => {
    await tx.user.update({
      where: { id: fromUserId },
      data: { points: { decrement: amount } }
    })
    
    await tx.user.update({
      where: { id: toUserId },
      data: { points: { increment: amount } }
    })
  })
}

// ✅ 使用select优化查询
const user = await prisma.user.findUnique({
  where: { id: 1 },
  select: {
    id: true,
    username: true,
    email: true
    // 不查询password等敏感字段
  }
})

// ✅ 使用include联表查询
const novel = await prisma.novel.findUnique({
  where: { id: 1 },
  include: {
    author: true,
    comments: {
      take: 10,
      orderBy: { createdAt: 'desc' }
    }
  }
})

// ✅ 批量操作
await prisma.novel.updateMany({
  where: { authorId: 1 },
  data: { status: 'archived' }
})
```

---

## 🧪 测试规范

### 单元测试

```typescript
// tests/unit/services/novel.service.spec.ts
import { describe, it, expect, beforeEach } from 'vitest'
import { NovelService } from '@/services/novel.service'

describe('NovelService', () => {
  let service: NovelService
  
  beforeEach(() => {
    service = new NovelService()
  })
  
  describe('list', () => {
    it('应该返回小说列表', async () => {
      const result = await service.list(1, 20)
      
      expect(result).toHaveProperty('items')
      expect(result).toHaveProperty('pagination')
      expect(result.pagination.page).toBe(1)
    })
    
    it('应该正确分页', async () => {
      const result = await service.list(2, 10)
      
      expect(result.pagination.page).toBe(2)
      expect(result.pagination.pageSize).toBe(10)
    })
  })
  
  describe('getById', () => {
    it('应该返回指定ID的小说', async () => {
      const novel = await service.getById(1)
      
      expect(novel).toBeDefined()
      expect(novel?.id).toBe(1)
    })
    
    it('不存在的小说应该返回null', async () => {
      const novel = await service.getById(999999)
      
      expect(novel).toBeNull()
    })
  })
})
```

---

### 集成测试

```typescript
// tests/integration/api/novels.spec.ts
import { describe, it, expect } from 'vitest'
import { build } from '@/app'

describe('POST /api/novels', () => {
  it('应该创建小说', async () => {
    const app = await build()
    
    const response = await app.inject({
      method: 'POST',
      url: '/api/novels',
      headers: {
        authorization: 'Bearer ' + testToken
      },
      payload: {
        title: '测试小说',
        content: '测试内容'
      }
    })
    
    expect(response.statusCode).toBe(201)
    expect(response.json()).toMatchObject({
      success: true,
      data: {
        title: '测试小说'
      }
    })
  })
})
```

---

## 🔒 安全规范

### 密码处理

```typescript
import bcrypt from 'bcrypt'

// ✅ 密码加密
async function hashPassword(password: string): Promise<string> {
  const salt = await bcrypt.genSalt(10)
  return await bcrypt.hash(password, salt)
}

// ✅ 密码验证
async function verifyPassword(password: string, hash: string): Promise<boolean> {
  return await bcrypt.compare(password, hash)
}
```

---

### 输入验证

```typescript
// ✅ 使用Zod验证
import { z } from 'zod'

const registerSchema = z.object({
  username: z.string().min(3).max(20).regex(/^[a-zA-Z0-9_]+$/),
  email: z.string().email(),
  password: z.string().min(8).regex(/^(?=.*[a-z])(?=.*[A-Z])(?=.*\d)/),
})

// 使用
try {
  const data = registerSchema.parse(request.body)
  // 数据验证通过
} catch (error) {
  // 验证失败
}
```

---

### SQL注入防护

```typescript
// ✅ 使用Prisma（自动防护）
await prisma.user.findMany({
  where: {
    username: userInput // 安全，Prisma会处理
  }
})

// ❌ 永远不要这样
await prisma.$queryRaw`SELECT * FROM users WHERE username = ${userInput}` // 危险！
```

---

### XSS防护

```typescript
// ✅ 前端转义用户输入
import DOMPurify from 'dompurify'

const sanitized = DOMPurify.sanitize(userInput)
```

---

### CORS配置

```typescript
// ✅ 严格的CORS配置
fastify.register(cors, {
  origin: process.env.NODE_ENV === 'production' 
    ? ['https://xs.momofx.cn']
    : ['http://localhost:5188', 'http://127.0.0.1:5188'],
  credentials: true,
  methods: ['GET', 'POST', 'PUT', 'DELETE']
})
```

---

## ⚡ 性能规范

### 查询优化

```typescript
// ✅ 使用索引
await prisma.novel.findMany({
  where: {
    category: 'romance' // 确保category字段有索引
  }
})

// ✅ 限制返回字段
await prisma.user.findMany({
  select: {
    id: true,
    username: true
    // 不返回不需要的字段
  }
})

// ✅ 分页查询
await prisma.novel.findMany({
  skip: (page - 1) * pageSize,
  take: pageSize
})
```

---

### 缓存策略

```typescript
import Redis from 'ioredis'

const redis = new Redis()

// ✅ 缓存热点数据
async function getPopularNovels() {
  const cacheKey = 'popular:novels'
  
  // 先查缓存
  const cached = await redis.get(cacheKey)
  if (cached) {
    return JSON.parse(cached)
  }
  
  // 缓存未命中，查数据库
  const novels = await prisma.novel.findMany({
    take: 10,
    orderBy: { views: 'desc' }
  })
  
  // 存入缓存（1小时）
  await redis.setex(cacheKey, 3600, JSON.stringify(novels))
  
  return novels
}
```

---

### 前端性能

```vue
<script setup lang="ts">
import { computed } from 'vue'

// ✅ 使用computed缓存计算结果
const expensiveValue = computed(() => {
  // 复杂计算...
  return result
})

// ✅ 使用v-memo优化列表渲染
</script>

<template>
  <div v-for="item in list" :key="item.id" v-memo="[item.id]">
    <!-- 只有item.id变化时才重新渲染 -->
  </div>
</template>
```

---

## 📋 代码审查清单

### 提交代码前自查

```
✅ 代码符合命名规范
✅ 没有console.log（除非必要）
✅ 没有注释掉的代码
✅ 类型定义完整
✅ 错误处理完善
✅ 添加了必要的注释
✅ 通过ESLint检查
✅ 通过测试
✅ 没有敏感信息（密码、密钥等）
✅ Git提交信息规范
```

---

## 🎯 持续改进

这份规范会持续更新，如有建议请提交给工程师A。

**最后更新：** 2025-10-27  
**维护者：** 工程师A  
**版本：** v1.0

